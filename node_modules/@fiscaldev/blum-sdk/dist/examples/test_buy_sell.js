"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buy = buy;
exports.sell = sell;
const ton_1 = require("@ton/ton");
const core_1 = require("@ton/core");
const crypto_1 = require("@ton/crypto");
const src_1 = require("../src");
async function buy({ tonClient, jettonAddress, mnemonics, tonAmount, slippage = 20 }) {
    const keyPair = await (0, crypto_1.mnemonicToPrivateKey)(mnemonics);
    const wallet = tonClient.open(ton_1.WalletContractV5R1.create({ workchain: 0, publicKey: keyPair.publicKey }));
    const sender = wallet.sender(keyPair.secretKey);
    const blumJetton = tonClient.open(src_1.BlumJetton.createFromAddress(core_1.Address.parse(jettonAddress)));
    const estimatedJettonData = await blumJetton.getCoinsForTons((0, core_1.toNano)(tonAmount));
    const estimatedJettonAmount = estimatedJettonData.coins;
    const estimatedFee = estimatedJettonData.fees + (0, core_1.toNano)("0.05");
    const limit = estimatedJettonAmount * (BigInt(100) - BigInt(slippage)) / BigInt(100);
    const txParams = await blumJetton.createBuyJetton(sender, {
        tonAmount: (0, core_1.toNano)(tonAmount) + estimatedFee,
        limit: limit,
    });
    const tx = await wallet.createTransfer({
        seqno: await wallet.getSeqno(),
        secretKey: keyPair.secretKey,
        messages: [(0, ton_1.internal)(txParams)],
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
    });
    await wallet.send(tx);
    return estimatedJettonAmount;
}
async function sell({ tonClient, jettonAddress, mnemonics, jettonAmount, slippage = 20 }) {
    const keyPair = await (0, crypto_1.mnemonicToPrivateKey)(mnemonics);
    const wallet = tonClient.open(ton_1.WalletContractV5R1.create({ workchain: 0, publicKey: keyPair.publicKey }));
    const blumJetton = tonClient.open(src_1.BlumJetton.createFromAddress(core_1.Address.parse(jettonAddress)));
    const jettonWalletAddress = (await blumJetton.getWalletAddress(wallet.address)).jettonOwnerAddress;
    if (!jettonWalletAddress) {
        throw new Error('Failed to retrieve jetton wallet address');
    }
    const blumJettonWallet = tonClient.open(src_1.BlumJettonWallet.createFromAddress(core_1.Address.parse(jettonWalletAddress.toString())));
    const estimatedTonData = await blumJetton.getTonsForCoins((0, core_1.toNano)(jettonAmount));
    const estimatedTonAmount = estimatedTonData.tons;
    const estimatedFee = estimatedTonData.fees;
    const limit = estimatedTonAmount * (BigInt(100) - BigInt(slippage)) / BigInt(100);
    const txParams = await blumJettonWallet.createSell({
        queryId: 0,
        amount: (0, core_1.toNano)(jettonAmount),
        minReceive: limit,
        fee: estimatedFee
    });
    const tx = await wallet.createTransfer({
        seqno: await wallet.getSeqno(),
        secretKey: keyPair.secretKey,
        messages: [(0, ton_1.internal)(txParams)],
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
    });
    await wallet.send(tx);
    return estimatedTonAmount;
}
const tonClient = new ton_1.TonClient({
    endpoint: 'https://toncenter.com/api/v2/jsonRPC',
    // apiKey: "your_api_key"
});
buy({
    tonClient,
    jettonAddress: 'EQCmF9eJucr_iW5Xpk9Au7l-jtRWRCOxTmNESSlbJ7F-8IdI',
    mnemonics: "".split(' '),
    tonAmount: '0.1',
}).then(console.log).catch(console.error);
sell({
    tonClient,
    jettonAddress: 'EQCmF9eJucr_iW5Xpk9Au7l-jtRWRCOxTmNESSlbJ7F-8IdI',
    mnemonics: "".split(' '),
    jettonAmount: '100000',
}).then(console.log).catch(console.error);
//# sourceMappingURL=test_buy_sell.js.map