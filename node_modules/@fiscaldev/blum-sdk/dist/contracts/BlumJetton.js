"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlumJetton = void 0;
const core_1 = require("@ton/core");
class BlumJetton {
    constructor(address) {
        this.address = address;
    }
    static createFromAddress(address) {
        return new BlumJetton(address);
    }
    async getJettonData(provider) {
        const source = (await provider.get('get_jetton_data')).stack;
        const ctxTotalSupply = source.pop().value;
        const mintable = source.pop().value;
        const ctxAdminCell = source.pop().cell;
        const ctxAdmin = ctxAdminCell.asSlice().loadAddressAny();
        const ctxContent = source.pop();
        const ctxWalletCode = source.pop();
        return {
            ctxTotalSupply,
            mintable,
            ctxAdmin,
            ctxContent,
            ctxWalletCode,
        };
    }
    async getWalletAddress(provider, ownerAddress) {
        const builder = new core_1.TupleBuilder();
        builder.writeAddress(ownerAddress);
        const source = (await provider.get('get_wallet_address', builder.build())).stack;
        const ownerAddressCell = source.pop().cell;
        const jettonOwnerAddress = ownerAddressCell.asSlice().loadAddressAny();
        return {
            jettonOwnerAddress,
        };
    }
    async getCoinPrice(provider) {
        const source = (await provider.get('coin_price')).stack;
        const coinPrice = source.pop().value;
        return {
            coinPrice,
        };
    }
    async getCoinsForTons(provider, tons, checkTradingState = true) {
        const tradingState = await this.getTradingState(provider);
        if (!tradingState.tradingEnabled && checkTradingState) {
            throw new Error('Trading is disabled');
        }
        const builder = new core_1.TupleBuilder();
        builder.writeNumber(tons);
        const source = (await provider.get('coins_for_tons', builder.build())).stack;
        const fees = source.pop().value;
        const coins = source.pop().value;
        return {
            fees,
            coins,
        };
    }
    async getTonsForCoins(provider, coins, checkTradingState = true) {
        const tradingState = await this.getTradingState(provider);
        if (!tradingState.tradingEnabled && checkTradingState) {
            throw new Error('Trading is disabled');
        }
        const builder = new core_1.TupleBuilder();
        builder.writeNumber(coins);
        const source = (await provider.get('tons_for_coins', builder.build())).stack;
        const fees = source.pop().value;
        const tons = source.pop().value;
        return {
            fees,
            tons,
        };
    }
    async getBclData(provider) {
        const source = (await provider.get('get_bcl_data')).stack;
        return {
            ctxTotalSupply: source.readBigNumber(),
            ctxBclSupply: source.readBigNumber(),
            ctxLiqSupply: source.readBigNumber(),
            ctxAdmin: source.readAddressOpt(),
            ctxAuthorAddress: source.readAddressOpt(),
            ctxContent: source.readCellOpt(),
            ctxFeeAddress: source.readAddressOpt(),
            ctxTradeFeeNumerator: source.readBigNumber(),
            ctxTradeFeeDenominator: source.readBigNumber(),
            ctxTtl: source.readBigNumber(),
            ctxLastTradeDate: source.readBigNumber(),
            ctxTradingEnabled: source.readBigNumber(),
            ctxTonLiqCollected: source.readBigNumber(),
            ctxReferral: source.readCellOpt(),
            ctxTradingCloseFee: source.readBigNumber(),
            fullPriceTonNeed: source.readBigNumber(),
            fullPriceTonFees: source.readBigNumber(),
            ctxRouterAddress: source.readAddressOpt(),
            ctxRouterPtonWalletAddress: source.readAddressOpt(),
        };
    }
    async getTradingState(provider) {
        const bclData = await this.getBclData(provider);
        const tradingEnabled = bclData.ctxTradingEnabled === 1n;
        return {
            tradingEnabled,
        };
    }
    async createBuyJetton(provider, options) {
        const { tonAmount, limit, queryId = 0, referral = null, buyerAddress = null, checkTradingState = true } = options;
        if (tonAmount < (0, core_1.toNano)("0.05")) {
            throw new Error('Minimum amount must be > 0.05 TON');
        }
        const tradingState = await this.getTradingState(provider);
        if (!tradingState.tradingEnabled && checkTradingState) {
            throw new Error('Trading is disabled');
        }
        let body = (0, core_1.beginCell)()
            .storeUint(BlumJetton.BUY, 32)
            .storeUint(queryId, 64)
            .storeCoins(limit)
            .storeMaybeRef(referral);
        if (buyerAddress) {
            body.storeAddress(buyerAddress);
        }
        return {
            to: this.address,
            value: tonAmount,
            body: body.endCell(),
        };
    }
}
exports.BlumJetton = BlumJetton;
BlumJetton.BUY = 0xaf750d34;
BlumJetton.SELL = 0x742b36d8;
//# sourceMappingURL=BlumJetton.js.map